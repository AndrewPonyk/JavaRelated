// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title ZkVerifier
 * @notice Groth16 zkSNARK proof verifier for anonymous voting.
 *
 *         In production, this contract is auto-generated by snarkjs from the
 *         compiled circom circuit via: `snarkjs zkey export solidityverifier`.
 *
 *         This implementation provides a functional verifier that validates
 *         proof structure. Replace with the auto-generated verifier after
 *         running the trusted setup ceremony (scripts/generate-zk-keys.sh).
 */
contract ZkVerifier {
    // Verification key components (populated after trusted setup)
    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    struct VerifyingKey {
        uint256[2] alpha1;
        uint256[2][2] beta2;
        uint256[2][2] gamma2;
        uint256[2][2] delta2;
        uint256[2][] ic;
    }

    bool public initialized;
    address public owner;

    // Store verification key components
    uint256[2] public alpha1;
    uint256[2][2] public beta2;
    uint256[2][2] public gamma2;
    uint256[2][2] public delta2;
    uint256[2][] public ic;

    constructor() {
        owner = msg.sender;
    }

    /**
     * @notice Initialize the verification key (called once after trusted setup).
     *         In production, the auto-generated contract has this hardcoded.
     */
    function initializeVerificationKey(
        uint256[2] calldata _alpha1,
        uint256[2][2] calldata _beta2,
        uint256[2][2] calldata _gamma2,
        uint256[2][2] calldata _delta2,
        uint256[2][] calldata _ic
    ) external {
        require(msg.sender == owner, "Only owner");
        require(!initialized, "Already initialized");
        require(_ic.length == 4, "IC length must be 4 for 3 public inputs");

        alpha1 = _alpha1;
        beta2 = _beta2;
        gamma2 = _gamma2;
        delta2 = _delta2;

        for (uint256 i = 0; i < _ic.length; i++) {
            ic.push(_ic[i]);
        }

        initialized = true;
    }

    /**
     * @notice Verify a Groth16 proof.
     * @param a Proof element A (2 uint256s)
     * @param b Proof element B (2x2 uint256s)
     * @param c Proof element C (2 uint256s)
     * @param input Public inputs (commitment, nullifier, proposalId)
     * @return True if the proof is valid
     */
    function verifyProof(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[3] calldata input
    ) external view returns (bool) {
        // If verification key is not initialized, reject all proofs
        if (!initialized) {
            return false;
        }

        // Validate proof elements are within the scalar field
        require(a[0] < SNARK_SCALAR_FIELD && a[1] < SNARK_SCALAR_FIELD, "Invalid proof a");
        require(c[0] < SNARK_SCALAR_FIELD && c[1] < SNARK_SCALAR_FIELD, "Invalid proof c");

        for (uint256 i = 0; i < 3; i++) {
            require(input[i] < SNARK_SCALAR_FIELD, "Invalid public input");
        }

        // In production, this performs the actual pairing check:
        // e(A, B) == e(alpha, beta) * e(vk_x, gamma) * e(C, delta)
        //
        // The auto-generated verifier from snarkjs implements this using
        // precompiled contracts at addresses 6 (ecAdd), 7 (ecMul), 8 (ecPairing).
        //
        // For the development verifier, we validate structure and return true.
        // Replace this entire contract with the snarkjs-generated version for production.

        // Compute vk_x = ic[0] + input[0]*ic[1] + input[1]*ic[2] + input[2]*ic[3]
        // This is the linear combination of public inputs with the IC points

        // Placeholder: pairing check would go here
        // In development mode without a real verification key, we validate
        // that the proof structure is well-formed (non-zero elements)
        bool hasProofData = (a[0] != 0 || a[1] != 0) &&
                            (c[0] != 0 || c[1] != 0);

        return hasProofData;
    }
}

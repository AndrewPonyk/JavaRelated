<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Naval Defense System</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: monospace;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        .hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 50, 0.8);
            border: 2px solid cyan;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            min-width: 200px;
        }

        .hud div {
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
        }

        #log {
            position: absolute;
            top: 50px;
            right: 20px;
            width: 300px;
            text-align: right;
            pointer-events: none;
            font-size: 14px;
            color: #aaa;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            display: flex;
            gap: 10px;
        }

        button {
            background: cyan;
            color: black;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
        }

        button:hover {
            background: #00aaaa;
        }

        .overlay-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 10px black;
            display: none;
            z-index: 100;
        }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">NAVAL DEFENSE: INTERCEPTOR PHALANX</div>

    <div id="controls">
        <button id="pause-btn">PAUSE</button>
        <button id="view-btn">JET VIEW</button>
    </div>

    <div class="hud">
        <div style="color:cyan; border-bottom: 1px solid cyan; padding-bottom:5px; margin-bottom:10px;">SYSTEM STATUS
        </div>
        <div><span>HULL:</span> <span id="hull" style="color:lime">100%</span></div>
        <div><span>KILLS:</span> <span id="score">0</span></div>
        <div><span>THREATS:</span> <span id="threats">0</span></div>
        <div><span>WAVE:</span> <span id="wave">0/20</span></div>
    </div>
    <div id="log"></div>
    <div id="victory-msg" class="overlay-msg" style="color: lime;">MISSION ACCOMPLISHED</div>
    <div id="fail-msg" class="overlay-msg" style="color: red;">SHIP DESTROYED</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Config ---
        const CONFIG = {
            missileSpeed: 450,
            jetSpeed: 180,
            spawnRate: 6000,
            totalJets: 20,
            gravity: 120
        };

        // --- Globals ---
        let scene, camera, renderer, controls;
        let clock = new THREE.Clock();

        let isPaused = false;
        let gameActive = true;
        let cameraMode = 'ORBIT'; // 'ORBIT' or 'COCKPIT'
        let currentJet = null;

        // Objects
        let shipGroup;
        const enemies = [];
        const projectiles = []; // Missiles
        const particles = []; // For explosions/smoke

        // Game State
        let hullIntegrity = 100;
        let score = 0;
        let lastSpawn = 0;
        let jetsSpawned = 0;

        // --- Init ---
        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x88ccff); // Clear Sky
            scene.fog = new THREE.FogExp2(0x88ccff, 0.0002);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 8000);
            camera.position.set(-250, 120, 250);
            camera.lookAt(0, 50, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxDistance = 3000;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // Don't go under water

            // Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(500, 1000, 500);
            sun.castShadow = true;
            sun.shadow.mapSize.set(2048, 2048);
            const d = 800;
            sun.shadow.camera.left = -d; sun.shadow.camera.right = d;
            sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
            scene.add(sun);

            // Environment
            buildWater();
            buildShip();

            // UI Listeners
            document.getElementById('pause-btn').addEventListener('click', () => {
                isPaused = !isPaused;
                document.getElementById('pause-btn').innerText = isPaused ? "RESUME" : "PAUSE";
                document.getElementById('pause-btn').style.background = isPaused ? "orange" : "cyan";
                log(isPaused ? "Simulation Paused" : "Simulation Resumed");
            });

            document.getElementById('view-btn').addEventListener('click', () => {
                if (cameraMode === 'ORBIT') {
                    // Try to find a valid jet
                    const validJet = enemies.find(e => e.state === 'FLYING');
                    if (validJet) {
                        cameraMode = 'COCKPIT';
                        currentJet = validJet;
                        document.getElementById('view-btn').innerText = "SHIP VIEW";
                        document.getElementById('view-btn').style.background = "lime";
                        controls.enabled = false;
                        log("Camera: Pilot View");
                    } else {
                        log("No active jets to view!");
                    }
                } else {
                    cameraMode = 'ORBIT';
                    currentJet = null;
                    document.getElementById('view-btn').innerText = "JET VIEW";
                    document.getElementById('view-btn').style.background = "cyan";
                    controls.enabled = true;
                    // Reset cam pos
                    camera.position.set(-250, 150, 250);
                    camera.lookAt(0, 0, 0);
                    log("Camera: Orbit View");
                }
            });

            // Window
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            log("System Initialized. Wave incoming.");
        }

        function log(msg) {
            const el = document.getElementById('log');
            const line = document.createElement('div');
            line.innerText = msg;
            el.appendChild(line);
            if (el.children.length > 5) el.removeChild(el.firstChild);
        }

        function buildWater() {
            const geo = new THREE.PlaneGeometry(10000, 10000);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x0066aa,
                roughness: 0.1,
                metalness: 0.1
            });
            const water = new THREE.Mesh(geo, mat);
            water.rotation.x = -Math.PI / 2;
            water.receiveShadow = true;
            scene.add(water);
        }

        function buildShip() {
            shipGroup = new THREE.Group();

            const hullMat = new THREE.MeshStandardMaterial({ color: 0x556677 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x223344 });

            // Hull
            const hull = new THREE.Mesh(new THREE.BoxGeometry(200, 25, 40), hullMat);
            hull.position.y = 12.5;
            hull.castShadow = true;
            shipGroup.add(hull);

            // Deck
            const deck = new THREE.Mesh(new THREE.BoxGeometry(198, 2, 38), darkMat);
            deck.position.y = 26;
            shipGroup.add(deck);

            // Superstructure front
            const bridge = new THREE.Mesh(new THREE.BoxGeometry(30, 25, 25), hullMat);
            bridge.position.set(30, 37, 0);
            bridge.castShadow = true;
            shipGroup.add(bridge);

            // Radar
            const mast = new THREE.Mesh(new THREE.CylinderGeometry(1, 2, 20), darkMat);
            mast.position.set(20, 50, 0);
            shipGroup.add(mast);

            // VLS (Missile Bay)
            const vls = new THREE.Mesh(new THREE.PlaneGeometry(15, 15), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            vls.rotation.x = -Math.PI / 2;
            vls.position.set(60, 27.1, 0);
            shipGroup.add(vls);

            scene.add(shipGroup);
        }

        // --- Factories ---
        function createJet(pos) {
            const group = new THREE.Group();

            // Materials
            const matBody = new THREE.MeshStandardMaterial({ color: 0x607485, roughness: 0.4, metalness: 0.5 });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
            const matGlass = new THREE.MeshPhysicalMaterial({
                color: 0xffccaa,
                metalness: 0.9,
                roughness: 0.0,
                transmission: 0.6, // Glass-like
                transparent: true,
                opacity: 0.5
            });
            const matBurner = new THREE.MeshBasicMaterial({ color: 0xffaa44 });

            // 1. Fuselage (Blended Body)
            const fuseGeo = new THREE.CylinderGeometry(1.0, 1.4, 11, 24);
            fuseGeo.rotateX(Math.PI / 2);
            const fuse = new THREE.Mesh(fuseGeo, matBody);
            group.add(fuse);

            // 2. Nose Cone (Sharp)
            const noseGeo = new THREE.ConeGeometry(1.0, 5, 24);
            noseGeo.rotateX(Math.PI / 2);
            const nose = new THREE.Mesh(noseGeo, matBody);
            nose.position.z = 8;
            group.add(nose);

            // 3. Air Intake (Ventral)
            const intakeShape = new THREE.Shape();
            intakeShape.moveTo(-0.8, 0);
            intakeShape.lineTo(-0.6, -1.2);
            intakeShape.bezierCurveTo(-0.3, -1.5, 0.3, -1.5, 0.6, -1.2); // Curved bottom
            intakeShape.lineTo(0.8, 0);
            const intakeGeo = new THREE.ExtrudeGeometry(intakeShape, { depth: 3, bevelEnabled: false });
            intakeGeo.rotateY(Math.PI); // Face forward? No, Extrude goes Z+. 
            const intake = new THREE.Mesh(intakeGeo, matDark);
            intake.position.set(0, -0.8, 2);
            // Fix orientation
            intake.rotation.y = Math.PI;
            intake.position.z = 5; // Move fwd
            group.add(intake);

            // 4. Cockpit Bubble
            const canopyGeo = new THREE.CapsuleGeometry(1.1, 3.5, 4, 16);
            canopyGeo.rotateX(Math.PI / 2);
            const canopy = new THREE.Mesh(canopyGeo, matGlass);
            canopy.position.set(0, 0.8, 2.5);
            canopy.scale.set(0.9, 0.7, 1);
            group.add(canopy);

            // 5. Cockpit Interior (For Pilot View)
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.8), matDark);
            seat.position.set(0, 0.2, 2.0);
            group.add(seat);

            const dashGeo = new THREE.BoxGeometry(1.2, 0.6, 0.8);
            const dash = new THREE.Mesh(dashGeo, matDark);
            dash.position.set(0, 0.5, 3.2); // In front of seat
            group.add(dash);

            // HUD Glass (Holographic)
            const hudGeo = new THREE.PlaneGeometry(0.7, 0.9);
            const hudMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
            const hud = new THREE.Mesh(hudGeo, hudMat);
            hud.position.set(0, 1.1, 3.8);
            hud.rotation.x = -0.2;
            group.add(hud);

            // 6. Wings (Delta - Extruded Shape)
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(6.5, -4);
            wingShape.lineTo(6.5, -6);
            wingShape.lineTo(1.5, -5);
            wingShape.lineTo(1.5, 3); // Lerex (Leading Edge Root Extension)

            const wingGeo = new THREE.ExtrudeGeometry(wingShape, { depth: 0.1, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 });
            wingGeo.rotateX(-Math.PI / 2); // Flatten

            const leftWing = new THREE.Mesh(wingGeo, matBody);
            leftWing.position.set(0.9, 0, 1);
            group.add(leftWing);

            const rightWing = new THREE.Mesh(wingGeo, matBody);
            rightWing.scale.x = -1; // Mirror
            rightWing.position.set(-0.9, 0, 1);
            // Flip normals compensation not automatically handled by scale -1 in some older three versions, but works mostly.
            // But we need to ensure Side is Double or correct winding. 
            // MeshStandardMaterial usually culls back.
            // Let's force double side for wing material just in case.
            matBody.side = THREE.DoubleSide;
            group.add(rightWing);

            // 7. Stabilizers
            // Vertical Tail
            const vTailShape = new THREE.Shape();
            vTailShape.moveTo(0, 0);
            vTailShape.lineTo(0, 4);
            vTailShape.lineTo(1.5, 4);
            vTailShape.lineTo(3.5, 0);
            const vTailGeo = new THREE.ExtrudeGeometry(vTailShape, { depth: 0.2, bevelEnabled: false });
            vTailGeo.rotateY(Math.PI / 2);
            vTailGeo.translate(0, 0, -5); // Move back
            const vTail = new THREE.Mesh(vTailGeo, matBody);
            vTail.position.y = 1.2;
            group.add(vTail);

            // Horizontal Tail (Elevators)
            const hTailShape = new THREE.Shape();
            hTailShape.moveTo(0, 0);
            hTailShape.lineTo(3, -2);
            hTailShape.lineTo(3, -3.5);
            hTailShape.lineTo(0, -2.5);
            const hTailGeo = new THREE.ExtrudeGeometry(hTailShape, { depth: 0.1, bevelEnabled: true, bevelThickness: 0.02 });
            hTailGeo.rotateX(-Math.PI / 2);

            const lStab = new THREE.Mesh(hTailGeo, matBody);
            lStab.position.set(0.8, -0.2, -5);
            group.add(lStab);

            const rStab = new THREE.Mesh(hTailGeo, matBody);
            rStab.scale.x = -1;
            rStab.position.set(-0.8, -0.2, -5);
            group.add(rStab);

            // 8. Engine Nozzle
            const nozzleGeo = new THREE.CylinderGeometry(0.9, 1.1, 1.5, 24, 1, true);
            nozzleGeo.rotateX(Math.PI / 2);
            const nozzle = new THREE.Mesh(nozzleGeo, matDark);
            nozzle.position.z = -6.2;
            group.add(nozzle);

            const glow = new THREE.Mesh(new THREE.CircleGeometry(0.8, 16), matBurner);
            glow.position.z = -7;
            glow.rotation.x = Math.PI;
            group.add(glow);

            // 9. Armament (Sidewinders)
            const misGeo = new THREE.CylinderGeometry(0.1, 0.1, 3.5);
            misGeo.rotateX(Math.PI / 2);
            const misMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });

            const lMis = new THREE.Mesh(misGeo, misMat);
            lMis.position.set(6.8, -0.1, -4);
            group.add(lMis);

            const rMis = new THREE.Mesh(misGeo, misMat);
            rMis.position.set(-6.8, -0.1, -4);
            group.add(rMis);

            group.position.copy(pos);
            group.lookAt(0, 50, 0);
            scene.add(group);

            return {
                mesh: group,
                hp: 1,
                state: 'FLYING',
                velocity: new THREE.Vector3(),
                spin: new THREE.Vector3(),
                cooldown: 0
            };
        }

        function createMissile(pos, target, isEnemy) {
            const group = new THREE.Group();

            // Rocket Body
            const matBody = new THREE.MeshStandardMaterial({
                color: isEnemy ? 0xcc2200 : 0xdddddd,
                roughness: 0.3
            });
            const matFins = new THREE.MeshStandardMaterial({
                color: 0x333333
            });

            // Main Tube
            const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 6, 8), matBody);
            tube.rotation.x = Math.PI / 2;
            group.add(tube);

            // Nose Cone
            const cone = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.5, 8), matBody);
            cone.rotation.x = Math.PI / 2;
            cone.position.z = 3.75;
            group.add(cone);

            // Fins (Tail)
            const finGeo = new THREE.BoxGeometry(2, 0.1, 1);
            const fin1 = new THREE.Mesh(finGeo, matFins);
            fin1.position.z = -2.5;
            group.add(fin1);

            const fin2 = new THREE.Mesh(finGeo, matFins);
            fin2.position.z = -2.5;
            fin2.rotation.z = Math.PI / 2;
            group.add(fin2);

            // Flame/Glow (Engine)
            const flame = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0, 2), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
            flame.rotation.x = -Math.PI / 2;
            flame.position.z = -4;
            group.add(flame);

            group.position.copy(pos);

            if (isEnemy) {
                group.lookAt(target);
            } else {
                group.lookAt(pos.x, pos.y + 100, pos.z); // Up initially
            }
            scene.add(group);

            return {
                mesh: group,
                target: target,
                isEnemy: isEnemy,
                phase: isEnemy ? 'CRUISE' : 'LAUNCH',
                life: 6.0
            };
        }

        // --- FX ---
        function spawnTracer(start, end) {
            const points = [];
            points.push(start);
            points.push(end);
            const geo = new THREE.BufferGeometry().setFromPoints(points);
            const mat = new THREE.LineBasicMaterial({ color: 0xffffaa, linewidth: 2 });
            const line = new THREE.Line(geo, mat);
            scene.add(line);

            // Remove after 1 frame
            setTimeout(() => {
                scene.remove(line);
                geo.dispose();
                mat.dispose();
            }, 50);
        }

        function spawnParticle(pos, color, size, life) {
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(size, size, size),
                new THREE.MeshBasicMaterial({ color: color, transparent: true })
            );
            mesh.position.copy(pos);
            // Random spread
            mesh.position.add(new THREE.Vector3((Math.random() - .5) * 5, (Math.random() - .5) * 5, (Math.random() - .5) * 5));
            scene.add(mesh);

            particles.push({
                mesh: mesh,
                life: life,
                maxLife: life,
                vel: new THREE.Vector3((Math.random() - .5) * 10, (Math.random() - .5) * 10, (Math.random() - .5) * 10)
            });
        }

        function createSmallExplosion(pos) {
            // Flash
            spawnParticle(pos, 0xffff00, 4, 0.2);
            // Debris/Smoke
            for (let i = 0; i < 5; i++) {
                spawnParticle(pos, 0x555555, 2, 1.0 + Math.random());
            }
        }

        function createSplash(pos) {
            for (let i = 0; i < 15; i++) {
                spawnParticle(pos, 0xffffff, 3, 0.8 + Math.random());
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (cameraMode === 'COCKPIT' && currentJet) {
                // If jet is still valid
                if (enemies.includes(currentJet) && (currentJet.state === 'FLYING' || currentJet.state === 'CRASHING')) {
                    // Update camera position to be INSIDE the cockpit
                    const jetPos = currentJet.mesh.position.clone();
                    const jetQuat = currentJet.mesh.quaternion;

                    // Offset: Up 1.0, Forward 2.2 (Pilot head position)
                    const offset = new THREE.Vector3(0, 1.0, 2.2);
                    offset.applyQuaternion(jetQuat);
                    camera.position.copy(jetPos).add(offset);

                    // Look Forward + slight down angle to see instruments
                    const forward = new THREE.Vector3(0, -0.1, 10).applyQuaternion(jetQuat);
                    camera.lookAt(jetPos.clone().add(forward));

                    // Match UP vector for banking
                    const up = new THREE.Vector3(0, 1, 0).applyQuaternion(jetQuat);
                    camera.up.copy(up);

                } else {
                    // Jet died
                    cameraMode = 'ORBIT';
                    controls.enabled = true;
                    document.getElementById('view-btn').innerText = "JET VIEW";
                    document.getElementById('view-btn').style.background = "cyan";
                    log("Signal Lost.");
                    camera.position.set(-250, 150, 250); // Reset cam
                    camera.lookAt(0, 0, 0);
                    camera.up.set(0, 1, 0);
                }
            } else {
                controls.update();
            }

            renderer.render(scene, camera);

            if (isPaused) return;

            const dt = 0.016; // Fixed timestep
            const now = Date.now();

            // Ship movement
            if (shipGroup) {
                shipGroup.position.y = Math.sin(now * 0.001) * 2;
                shipGroup.rotation.z = Math.sin(now * 0.0005) * 0.02;
            }

            // Spawn Logic
            if (gameActive && jetsSpawned < CONFIG.totalJets) {
                if (now - lastSpawn > CONFIG.spawnRate) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 1000 + Math.random() * 500;
                    const h = 200 + Math.random() * 150;

                    const pos = new THREE.Vector3(Math.cos(angle) * dist, h, Math.sin(angle) * dist);
                    const enemy = createJet(pos);
                    enemies.push(enemy);
                    jetsSpawned++;

                    log(`Bogie incoming! (${jetsSpawned}/${CONFIG.totalJets})`);
                    lastSpawn = now;
                }
            } else if (gameActive && jetsSpawned >= CONFIG.totalJets && enemies.length === 0) {
                gameActive = false;
                document.getElementById('victory-msg').style.display = 'block';
                log("All targets secured.");
            }

            // --- Update Enemies ---
            const shipPos = new THREE.Vector3(0, 40, 0);

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                if (e.state === 'FLYING') {
                    // Fly towards ship
                    const dir = shipPos.clone().sub(e.mesh.position).normalize();
                    e.mesh.lookAt(shipPos);

                    e.mesh.translateZ(CONFIG.jetSpeed * dt);

                    const dist = e.mesh.position.distanceTo(shipPos);

                    // Shoot Missile 
                    e.cooldown -= dt;
                    if (dist < 1000 && dist > 100 && e.cooldown <= 0) {
                        createMissile(e.mesh.position.clone(), shipPos, true).target = shipPos;
                        projectiles.push(createMissile(e.mesh.position.clone(), shipPos, true));
                        e.cooldown = 4.5; // Slower fire rate
                    }

                    // Crash into ship
                    if (dist < 40) {
                        createSmallExplosion(e.mesh.position);
                        damageShip(25); // Reduced damage
                        scene.remove(e.mesh);
                        enemies.splice(i, 1);
                        changeScore(0);
                        continue;
                    }

                    // Auto-Defend chance
                    if (dist < 900 && Math.random() < 0.018) { // Increased defense
                        const vlsPos = new THREE.Vector3(60, 40, 0).applyMatrix4(shipGroup.matrixWorld);
                        projectiles.push(createMissile(vlsPos, e, false));
                    }

                } else if (e.state === 'CRASHING') {
                    // Physics
                    e.velocity.y -= CONFIG.gravity * dt;
                    e.velocity.multiplyScalar(0.99);
                    e.mesh.position.add(e.velocity.clone().multiplyScalar(dt));

                    // Spin
                    e.mesh.rotation.x += e.spin.x * dt;
                    e.mesh.rotation.y += e.spin.y * dt;
                    e.mesh.rotation.z += e.spin.z * dt;

                    // Smoke Trail
                    if (Math.random() < 0.4) {
                        spawnParticle(e.mesh.position, 0x333333, 2, 1.5);
                    }

                    // Water Intersect
                    if (e.mesh.position.y <= 0) {
                        createSplash(e.mesh.position);
                        scene.remove(e.mesh);
                        enemies.splice(i, 1);
                        changeScore(1);
                        log("Splash one bandit.");
                    }
                }
            }

            // --- CIWS Logic (Point Defense) ---
            // Scan for incoming missiles within range
            const ciwsRange = 500;

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                if (!p.isEnemy) continue; // Only shoot enemy missiles

                const dist = p.mesh.position.distanceTo(shipPos);

                // If missile is close, CIWS engages
                if (dist < ciwsRange && dist > 50) {
                    // Visual Tracers (Simple lines)
                    if (Math.random() < 0.3) {
                        spawnTracer(new THREE.Vector3(20, 50, 0), p.mesh.position);
                    }

                    // 40% Chance to intercept per second (approx)
                    // At 60fps, 0.4 chance per second means roughly 0.008 per frame
                    // We need it to be effective but not 100%. 
                    // Let's check a flat chance if it hasn't been checked recently? 
                    // Simpler: small constant chance per frame
                    if (Math.random() < 0.02) {
                        createSmallExplosion(p.mesh.position);
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        log("CIWS intercept.");
                    }
                }
            }

            // --- Update Projectiles ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.life -= dt;

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }

                if (p.isEnemy) {
                    const dir = p.target.clone().sub(p.mesh.position).normalize();
                    p.mesh.position.add(dir.multiplyScalar(CONFIG.missileSpeed * dt));
                    p.mesh.lookAt(p.target);

                    if (p.mesh.position.distanceTo(p.target) < 20) {
                        createSmallExplosion(p.mesh.position);
                        damageShip(10);
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                    }
                } else {
                    if (p.phase === 'LAUNCH') {
                        p.mesh.position.y += 150 * dt;
                        if (p.mesh.position.y > 100) p.phase = 'TRACK';
                    } else {
                        if (!p.target || !p.target.mesh || !enemies.includes(p.target)) {
                            p.life = 0; continue;
                        }

                        const targetPos = p.target.mesh.position.clone();
                        const dir = targetPos.sub(p.mesh.position).normalize();
                        p.mesh.position.add(dir.multiplyScalar(CONFIG.missileSpeed * dt));
                        p.mesh.lookAt(p.target.mesh.position);

                        if (p.mesh.position.distanceTo(p.target.mesh.position) < 15) {
                            createSmallExplosion(p.target.mesh.position);
                            const e = p.target;
                            if (e.state === 'FLYING') {
                                e.state = 'CRASHING';
                                e.velocity = e.mesh.getWorldDirection(new THREE.Vector3()).multiplyScalar(CONFIG.jetSpeed);
                                e.spin = new THREE.Vector3(Math.random(), Math.random(), Math.random()).multiplyScalar(5);
                            }
                            scene.remove(p.mesh);
                            projectiles.splice(i, 1);
                        }
                    }
                }
            }

            // --- Update Particles ---
            for (let i = particles.length - 1; i >= 0; i--) {
                const pt = particles[i];
                pt.life -= dt;
                pt.mesh.position.add(pt.vel.clone().multiplyScalar(dt));
                pt.mesh.scale.multiplyScalar(0.95); // Shrink or fade
                pt.mesh.material.opacity = pt.life / pt.maxLife;

                if (pt.life <= 0) {
                    scene.remove(pt.mesh);
                    particles.splice(i, 1);
                }
            }

            // UI
            document.getElementById('threats').innerText = enemies.filter(e => e.state === 'FLYING').length;
            document.getElementById('wave').innerText = jetsSpawned + "/" + CONFIG.totalJets;
        }

        function damageShip(amt) {
            if (!gameActive) return;
            hullIntegrity -= amt;
            if (hullIntegrity < 0) hullIntegrity = 0;
            if (hullIntegrity < 30) document.getElementById('hull').style.color = 'red';
            document.getElementById('hull').innerText = Math.floor(hullIntegrity) + "%";

            camera.position.x += (Math.random() - .5) * 10;

            if (hullIntegrity <= 0) {
                hullIntegrity = 0;
                gameActive = false;
                document.getElementById('fail-msg').style.display = 'block';
                log("CRITICAL FAILURE.");
            }
        }

        function changeScore(amt) {
            score += amt;
            document.getElementById('score').innerText = score;
        }

    </script>
</body>

</html>
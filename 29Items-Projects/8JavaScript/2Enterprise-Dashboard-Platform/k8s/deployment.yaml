# =============================================================================
# ENTERPRISE DASHBOARD PLATFORM - KUBERNETES DEPLOYMENT MANIFESTS
# =============================================================================
#
# Production-ready Kubernetes deployment configuration with:
# - High availability and scaling
# - Resource management and limits
# - Health checks and readiness probes
# - Security contexts and policies
# - Service mesh integration ready
#
# =============================================================================

apiVersion: apps/v1
kind: Deployment
metadata:
  name: dashboard-backend
  namespace: ${NAMESPACE}
  labels:
    app: enterprise-dashboard
    component: backend
    version: ${VERSION}
    environment: ${ENVIRONMENT}
  annotations:
    deployment.kubernetes.io/revision: "${BUILD_NUMBER:-1}"
    app.kubernetes.io/version: "${VERSION}"
    app.kubernetes.io/managed-by: "enterprise-dashboard-platform"
spec:
  replicas: ${REPLICAS}
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  selector:
    matchLabels:
      app: enterprise-dashboard
      component: backend
  template:
    metadata:
      labels:
        app: enterprise-dashboard
        component: backend
        version: ${VERSION}
        environment: ${ENVIRONMENT}
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "3001"
        prometheus.io/path: "/metrics"
        sidecar.istio.io/inject: "true"
    spec:
      # Security Context
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        runAsGroup: 1001
        fsGroup: 1001

      # Service Account
      serviceAccountName: dashboard-backend

      # Pod Anti-Affinity for High Availability
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - enterprise-dashboard
                - key: component
                  operator: In
                  values:
                  - backend
              topologyKey: kubernetes.io/hostname

      # Init Containers
      initContainers:
      - name: migration
        image: ${DOCKER_REGISTRY}/${GITHUB_REPOSITORY}/${IMAGE_NAME}:${VERSION}
        command: ["npx", "prisma", "migrate", "deploy"]
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: dashboard-secrets
              key: database-url
        - name: NODE_ENV
          value: "production"
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: true
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 500m
            memory: 512Mi

      # Main Application Container
      containers:
      - name: backend
        image: ${DOCKER_REGISTRY}/${GITHUB_REPOSITORY}/${IMAGE_NAME}:${VERSION}
        imagePullPolicy: Always

        # Ports
        ports:
        - name: http
          containerPort: 3001
          protocol: TCP
        - name: websocket
          containerPort: 3002
          protocol: TCP

        # Environment Variables
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "3001"
        - name: WEBSOCKET_PORT
          value: "3002"
        - name: HOST
          value: "0.0.0.0"
        - name: APP_NAME
          value: "Enterprise Dashboard Platform"
        - name: APP_VERSION
          value: "${VERSION}"

        # Database Configuration
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: dashboard-secrets
              key: database-url
        - name: DATABASE_POOL_SIZE
          value: "${DATABASE_POOL_SIZE}"

        # Redis Configuration
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: dashboard-secrets
              key: redis-url

        # Security Configuration
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: dashboard-secrets
              key: jwt-secret
        - name: SESSION_SECRET
          valueFrom:
            secretKeyRef:
              name: dashboard-secrets
              key: session-secret
        - name: BCRYPT_ROUNDS
          value: "12"

        # CORS Configuration
        - name: CORS_ORIGIN
          value: "https://${DOMAIN}"

        # Security Features
        - name: HELMET_ENABLED
          value: "true"
        - name: RATE_LIMIT_ENABLED
          value: "true"
        - name: CSRF_ENABLED
          value: "true"
        - name: FORCE_HTTPS
          value: "true"

        # Logging Configuration
        - name: LOG_LEVEL
          value: "info"
        - name: LOG_FILE_ENABLED
          value: "true"
        - name: LOG_FILE_PATH
          value: "/app/logs"

        # Performance Configuration
        - name: MAX_CONCURRENT_REQUESTS
          value: "1000"
        - name: REQUEST_TIMEOUT
          value: "30000"
        - name: ENABLE_COMPRESSION
          value: "true"

        # Health Check Configuration
        - name: HEALTH_CHECK_ENABLED
          value: "true"
        - name: HEALTH_CHECK_DATABASE
          value: "true"
        - name: HEALTH_CHECK_REDIS
          value: "true"

        # Monitoring Configuration
        - name: PERFORMANCE_MONITORING_ENABLED
          value: "true"
        - name: SENTRY_DSN
          valueFrom:
            secretKeyRef:
              name: dashboard-secrets
              key: sentry-dsn
              optional: true

        # Resource Requirements
        resources:
          requests:
            cpu: ${RESOURCES_CPU}
            memory: ${RESOURCES_MEMORY}
          limits:
            cpu: $((${RESOURCES_CPU%m} * 2))m
            memory: $((${RESOURCES_MEMORY%Gi} * 2))Gi

        # Security Context
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          readOnlyRootFilesystem: false

        # Volume Mounts
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: uploads
          mountPath: /app/uploads
        - name: tmp
          mountPath: /app/tmp

        # Health Checks
        livenessProbe:
          httpGet:
            path: /health
            port: http
            scheme: HTTP
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
          successThreshold: 1

        readinessProbe:
          httpGet:
            path: /health
            port: http
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
          successThreshold: 1

        # Startup Probe
        startupProbe:
          httpGet:
            path: /health
            port: http
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 30
          successThreshold: 1

      # Volumes
      volumes:
      - name: logs
        emptyDir:
          sizeLimit: 5Gi
      - name: uploads
        persistentVolumeClaim:
          claimName: dashboard-uploads-pvc
      - name: tmp
        emptyDir:
          sizeLimit: 1Gi

      # Image Pull Secrets
      imagePullSecrets:
      - name: docker-registry-secret

      # Termination Grace Period
      terminationGracePeriodSeconds: 30

      # DNS Policy
      dnsPolicy: ClusterFirst

      # Restart Policy
      restartPolicy: Always

---
# Service for Backend
apiVersion: v1
kind: Service
metadata:
  name: dashboard-service
  namespace: ${NAMESPACE}
  labels:
    app: enterprise-dashboard
    component: backend
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: ${SSL_CERT_ARN}
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "https"
spec:
  type: LoadBalancer
  ports:
  - name: http
    port: 80
    targetPort: http
    protocol: TCP
  - name: https
    port: 443
    targetPort: http
    protocol: TCP
  - name: websocket
    port: 3002
    targetPort: websocket
    protocol: TCP
  selector:
    app: enterprise-dashboard
    component: backend
  sessionAffinity: ClientIP

---
# Service Account for Backend
apiVersion: v1
kind: ServiceAccount
metadata:
  name: dashboard-backend
  namespace: ${NAMESPACE}
  labels:
    app: enterprise-dashboard
    component: backend
automountServiceAccountToken: true

---
# Role for Backend Service Account
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: dashboard-backend
  namespace: ${NAMESPACE}
rules:
- apiGroups: [""]
  resources: ["pods", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]

---
# Role Binding for Backend Service Account
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: dashboard-backend
  namespace: ${NAMESPACE}
subjects:
- kind: ServiceAccount
  name: dashboard-backend
  namespace: ${NAMESPACE}
roleRef:
  kind: Role
  name: dashboard-backend
  apiGroup: rbac.authorization.k8s.io

---
# Persistent Volume Claim for Uploads
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: dashboard-uploads-pvc
  namespace: ${NAMESPACE}
  labels:
    app: enterprise-dashboard
    component: storage
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 50Gi
  storageClassName: ${STORAGE_CLASS:-gp2}

---
# Horizontal Pod Autoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: dashboard-backend-hpa
  namespace: ${NAMESPACE}
  labels:
    app: enterprise-dashboard
    component: backend
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: dashboard-backend
  minReplicas: ${REPLICAS}
  maxReplicas: $((${REPLICAS} * 3))
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60

---
# Pod Disruption Budget
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: dashboard-backend-pdb
  namespace: ${NAMESPACE}
  labels:
    app: enterprise-dashboard
    component: backend
spec:
  minAvailable: 50%
  selector:
    matchLabels:
      app: enterprise-dashboard
      component: backend

---
# Network Policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: dashboard-backend-network-policy
  namespace: ${NAMESPACE}
  labels:
    app: enterprise-dashboard
    component: backend
spec:
  podSelector:
    matchLabels:
      app: enterprise-dashboard
      component: backend
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ${NAMESPACE}
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 3001
    - protocol: TCP
      port: 3002
  egress:
  - to: []
    ports:
    - protocol: TCP
      port: 5432  # PostgreSQL
    - protocol: TCP
      port: 6379  # Redis
    - protocol: TCP
      port: 443   # HTTPS
    - protocol: TCP
      port: 53    # DNS
    - protocol: UDP
      port: 53    # DNS